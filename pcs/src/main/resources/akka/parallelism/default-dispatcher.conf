
/*

We are using persistSync on our Akka Actors.

Thus:


 --- Why not use a ForkJoinPool ---

Best fit for: event-style tasks that are never joined, for example with Akka Actors.

Bad fit for: Blocking I/O operations (JDBC, Cassandra sync ES),
number crunching code that by virtue of calculation uses the thread,
because there are only a small number of threads, this can lead to thread starvation,
which means there are no more threads available and no more tasks can be executed, halting the system.


  --- Highly synchronous ---
This profile matches that of a traditional synchronous IO based web framework,
such as a Java servlet container. It uses large thread pools to handle blocking IO.

 It is useful for applications where most actions are doing database synchronous IO calls,
  such as accessing a database, and you donâ€™t want or need control over concurrency
  for different types of work.

  This profile is the simplest for handling blocking IO.

  In this profile, you would simply use the default execution context everywhere,
  but configure it to have ''a very large number of threads'' in its pool, like so:

*/
